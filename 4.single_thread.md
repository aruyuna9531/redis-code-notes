# redis 源码阅读笔记（4）线程模型

相关代码：[server.c](https://github.com/redis/redis/blob/unstable/src/server.c)，[networking.c](https://github.com/redis/redis/blob/unstable/src/networking.c)

redis服务本身不是严格的单线程，对于一些操作是另开线程的。

对于额外线程，[networking.c](https://github.com/redis/redis/blob/unstable/src/networking.c)文件定义的initThreadedIO()函数最后有说明额外线程只会做哪些事情（实际上只有一件事，就是IO）。

```cpp
// ...上面如果i=0（主线程）continue了 即主线程不会干下面的事情
/* Things we do only for the additional threads. */
pthread_t tid;
pthread_mutex_init(&io_threads_mutex[i],NULL);  // 这个是c++库函数 初始化一把锁
setIOPendingCount(i, 0);
pthread_mutex_lock(&io_threads_mutex[i]); /* Thread will be stopped. */ // c++库函数 上锁
if (pthread_create(&tid,NULL,IOThreadMain,(void*)(long)i) != 0) {   // 给所有子线程注册IOThreadMain入口函数
    serverLog(LL_WARNING,"Fatal: Can't initialize IO thread.");
    exit(1);
}
io_threads[i] = tid;
```

IOThreadMain入口函数定义在[networking.c](https://github.com/redis/redis/blob/unstable/src/networking.c)里。每个线程自己有个事件list，线程干的事情就是从列表中读写数据，无情的读写机器。

```cpp
if (io_threads_op == IO_THREADS_OP_WRITE) {
    writeToClient(c,0);     // 写操作
} else if (io_threads_op == IO_THREADS_OP_READ) {
    readQueryFromClient(c->conn);   // 读操作
} else {
    serverPanic("io_threads_op value is unknown");
}
```

这里的IO指的是各种网络IO，什么主从复制，集群等等要建立连接的IO，都是由额外线程执行。

整个Redis源代码里，除了函数定义，只有这个pthread_create这里出现了这个名词，因此可以认为：

（1）IOThreadMain函数其下的内容只与额外线程有关，主线程不会负责那些内容。

（2）不属于IOThreadMain范围内的工作，全部是主线程执行。

所以一般会称Redis是单线程模型。